# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# POLITECH AWARDS 2026 ‚Äî PR VOTING WORKFLOW
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#
# How it works:
#   1. Someone opens a PR proposing changes to the voting algorithm
#   2. Committee members (listed in CODEOWNERS) vote via GitHub reviews
#   3. After 48 hours OR when majority is reached, the PR is resolved
#
# Voting:
#   ‚úÖ Approve         = YES vote
#   ‚ùå Request Changes = NO vote
#
# Labels applied automatically:
#   vote:pending          ‚Äî Waiting for votes
#   vote:approved         ‚Äî Majority said yes
#   vote:rejected         ‚Äî Majority said no
#   vote:deadline-passed  ‚Äî 48 hours elapsed
#   ready-to-merge        ‚Äî Approved and ready for manual merge
#
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

name: PR Voting

on:
  pull_request:
    types: [opened]
  pull_request_review:
    types: [submitted]
  schedule:
    - cron: "0 */6 * * *" # Check for expired deadlines every 6 hours

permissions:
  pull-requests: write
  contents: read

jobs:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 1: NOTIFY
  # When a PR is opened, post voting instructions and set initial label
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  notify:
    if: github.event.action == 'opened'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            // Calculate deadline (48 hours from now)
            const deadline = new Date(Date.now() + 48*60*60*1000)
              .toISOString()
              .slice(0, 16) + ' UTC';

            // Add the "vote:pending" label
            await github.rest.issues.addLabels({
              ...context.repo,
              issue_number: context.issue.number,
              labels: ['vote:pending']
            });

            // Post instructions for voters
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: `üó≥Ô∏è **Voting open until ${deadline}** (48 hours)\n\n` +
                    `Committee: approve or request changes to cast your vote. ` +
                    `Majority required to merge.`
            });

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 2: TALLY
  # After each review, count votes and update status
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  tally:
    if: github.event_name == 'pull_request_review'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // ‚îÄ‚îÄ‚îÄ Step 1: Get committee members from CODEOWNERS ‚îÄ‚îÄ‚îÄ
            const codeowners = fs.readFileSync('.github/CODEOWNERS', 'utf8');
            const members = codeowners
              .match(/@[\w-]+/g)                    // Find all @mentions
              ?.map(m => m.slice(1).toLowerCase())  // Remove @ and lowercase
              || [];
            const majority = Math.floor(members.length / 2) + 1;

            // ‚îÄ‚îÄ‚îÄ Step 2: Fetch all reviews on this PR ‚îÄ‚îÄ‚îÄ
            const { data: reviews } = await github.rest.pulls.listReviews({
              ...context.repo,
              pull_number: context.issue.number
            });

            // ‚îÄ‚îÄ‚îÄ Step 3: Get each member's latest vote ‚îÄ‚îÄ‚îÄ
            // (Later reviews override earlier ones)
            const votes = {};
            for (const review of reviews) {
              const username = review.user.login.toLowerCase();
              if (members.includes(username)) {
                votes[username] = review.state;
              }
            }

            // ‚îÄ‚îÄ‚îÄ Step 4: Count yes/no/pending ‚îÄ‚îÄ‚îÄ
            const yes = Object.values(votes).filter(v => v === 'APPROVED').length;
            const no = Object.values(votes).filter(v => v === 'CHANGES_REQUESTED').length;
            const pending = members.length - Object.keys(votes).length;

            // ‚îÄ‚îÄ‚îÄ Step 5: Determine outcome ‚îÄ‚îÄ‚îÄ
            let status, label;
            if (yes >= majority) {
              status = '‚úÖ Approved';
              label = 'vote:approved';
            } else if (no >= majority) {
              status = '‚ùå Rejected';
              label = 'vote:rejected';
            } else {
              status = `‚è≥ ${yes}/${majority} approvals`;
              label = 'vote:pending';
            }

            // ‚îÄ‚îÄ‚îÄ Step 6: Update labels ‚îÄ‚îÄ‚îÄ
            // Remove old vote labels (except deadline-passed)
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              ...context.repo,
              issue_number: context.issue.number
            });

            for (const l of currentLabels) {
              if (l.name.startsWith('vote:') && l.name !== 'vote:deadline-passed') {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number: context.issue.number,
                  name: l.name
                }).catch(() => {}); // Ignore if already removed
              }
            }

            // Add new label
            await github.rest.issues.addLabels({
              ...context.repo,
              issue_number: context.issue.number,
              labels: [label]
            });

            // ‚îÄ‚îÄ‚îÄ Step 7: Post status update ‚îÄ‚îÄ‚îÄ
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: `**${status}** ‚Äî ${yes} yes, ${no} no, ${pending} pending`
            });

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 3: DEADLINE
  # Runs on schedule to close voting on PRs older than 48 hours
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  deadline:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // ‚îÄ‚îÄ‚îÄ Setup ‚îÄ‚îÄ‚îÄ
            const { data: openPRs } = await github.rest.pulls.list({
              ...context.repo,
              state: 'open'
            });
            const cutoff = Date.now() - 48*60*60*1000; // 48 hours ago

            // Get committee from CODEOWNERS
            const codeowners = fs.readFileSync('.github/CODEOWNERS', 'utf8');
            const mentions = codeowners.match(/@[\w-]+/g) || [];
            const members = mentions.map(m => m.slice(1).toLowerCase());
            const membersOriginal = mentions.map(m => m.slice(1)); // Keep original case for @mentions
            const majority = Math.floor(members.length / 2) + 1;

            // ‚îÄ‚îÄ‚îÄ Process each open PR ‚îÄ‚îÄ‚îÄ
            for (const pr of openPRs) {
              // Skip PRs less than 48 hours old
              if (new Date(pr.created_at) >= cutoff) continue;

              // Skip PRs already processed
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                ...context.repo,
                issue_number: pr.number
              });
              if (labels.some(l => l.name === 'vote:deadline-passed')) continue;

              // ‚îÄ‚îÄ‚îÄ Count final votes ‚îÄ‚îÄ‚îÄ
              const { data: reviews } = await github.rest.pulls.listReviews({
                ...context.repo,
                pull_number: pr.number
              });

              const votes = {};
              for (const review of reviews) {
                const username = review.user.login.toLowerCase();
                if (members.includes(username)) {
                  votes[username] = review.state;
                }
              }

              const yes = Object.values(votes).filter(v => v === 'APPROVED').length;
              const no = Object.values(votes).filter(v => v === 'CHANGES_REQUESTED').length;

              // Mark voting as closed
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number: pr.number,
                labels: ['vote:deadline-passed']
              });

              // ‚îÄ‚îÄ‚îÄ Handle outcome ‚îÄ‚îÄ‚îÄ
              // Pick a random committee member to take action
              const assignee = membersOriginal[Math.floor(Math.random() * membersOriginal.length)];

              if (yes >= majority) {
                // ‚úÖ APPROVED ‚Äî assign someone to merge
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number: pr.number,
                  labels: ['ready-to-merge']
                });
                await github.rest.issues.addAssignees({
                  ...context.repo,
                  issue_number: pr.number,
                  assignees: [assignee]
                });
                await github.rest.issues.createComment({
                  ...context.repo,
                  issue_number: pr.number,
                  body: `‚è∞ **Voting closed ‚Äî APPROVED**\n\n` +
                        `Final tally: ${yes} yes, ${no} no\n\n` +
                        `‚úÖ @${assignee} ‚Äî please review and merge when ready.`
                });

              } else if (no >= majority) {
                // ‚ùå REJECTED ‚Äî assign someone to close
                await github.rest.issues.addAssignees({
                  ...context.repo,
                  issue_number: pr.number,
                  assignees: [assignee]
                });
                await github.rest.issues.createComment({
                  ...context.repo,
                  issue_number: pr.number,
                  body: `‚è∞ **Voting closed ‚Äî REJECTED**\n\n` +
                        `Final tally: ${yes} yes, ${no} no\n\n` +
                        `‚ùå @${assignee} ‚Äî please close this PR.`
                });

              } else {
                // ü§î NO MAJORITY ‚Äî needs discussion
                await github.rest.issues.createComment({
                  ...context.repo,
                  issue_number: pr.number,
                  body: `‚è∞ **Voting closed ‚Äî NO MAJORITY**\n\n` +
                        `Final tally: ${yes} yes, ${no} no (needed ${majority})\n\n` +
                        `ü§î Committee should discuss and reach consensus.`
                });
              }
            }
