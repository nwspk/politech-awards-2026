# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# POLITECH AWARDS 2026 â€” PR VOTING WORKFLOW
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# How it works:
#   1. PR is marked "Ready for review" â€” voting comment posted with 48hr deadline
#   2. Committee members (listed in CODEOWNERS) vote via emoji reactions
#   3. When majority is reached, the PR is resolved
#   4. If no majority after 48 hours, non-voters are tagged daily until majority
#
# Voting (react to the bot's voting comment):
#   ğŸ‘ = YES vote
#   ğŸ‘ = NO vote
#
# Labels applied automatically:
#   vote:pending          â€” Waiting for votes
#   vote:approved         â€” Majority said yes
#   vote:rejected         â€” Majority said no
#   vote:deadline-passed  â€” 48 hours elapsed
#   ready-to-merge        â€” Approved and ready for manual merge
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: PR Voting

on:
  pull_request:
    types: [ready_for_review]  # Start voting when PR is marked ready (after iteration bot runs)
  pull_request_target:
    types: [labeled]           # Also start voting when 'start-vote' label is added manually
  issue_comment:
    types: [created]           # Re-tally when someone comments (as proxy for reaction activity)
  schedule:
    - cron: "0 12 * * *"      # Check daily at noon UTC â€” nag non-voters every 24 hours

permissions:
  pull-requests: write
  contents: read

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: NOTIFY
  # When a PR is opened, post voting instructions and set initial label
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  notify:
    if: >
      github.event.action == 'ready_for_review' ||
      (github.event.action == 'labeled' && github.event.label.name == 'start-vote')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            // Calculate deadline (48 hours from now)
            const deadline = new Date(Date.now() + 48*60*60*1000)
              .toISOString()
              .slice(0, 16) + ' UTC';

            // Add the "vote:pending" label
            await github.rest.issues.addLabels({
              ...context.repo,
              issue_number: context.issue.number,
              labels: ['vote:pending']
            });

            // Post voting comment (committee reacts to this!)
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: `ğŸ—³ï¸ **Voting open until ${deadline}** (48 hours)\n\n` +
                    `ğŸ‘ ğŸ‘ ğŸ˜„ ğŸ‰ ğŸ˜• â¤ï¸ ğŸš€ ğŸ‘€ â€” React to cast your vote. Majority required to merge.`
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: TALLY
  # Count emoji reactions on the voting comment and update status
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  tally:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // â”€â”€â”€ Step 1: Get committee members from CODEOWNERS â”€â”€â”€
            const codeowners = fs.readFileSync('.github/CODEOWNERS', 'utf8');
            const members = codeowners
              .match(/@[\w-]+/g)                    // Find all @mentions
              ?.map(m => m.slice(1).toLowerCase())  // Remove @ and lowercase
              || [];
            const majority = Math.floor(members.length / 2) + 1;

            // â”€â”€â”€ Step 2: Find the voting comment (posted by github-actions bot) â”€â”€â”€
            const { data: comments } = await github.rest.issues.listComments({
              ...context.repo,
              issue_number: context.issue.number
            });

            const votingComment = comments.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes('ğŸ—³ï¸') &&
              c.body.includes('Voting open')
            );

            if (!votingComment) {
              console.log('No voting comment found, skipping tally');
              return;
            }

            // â”€â”€â”€ Step 3: Fetch reactions on the voting comment â”€â”€â”€
            const { data: reactions } = await github.rest.reactions.listForIssueComment({
              ...context.repo,
              comment_id: votingComment.id
            });

            // â”€â”€â”€ Step 4: Count votes from committee members â”€â”€â”€
            // ğŸ‘ (+1) = YES, ğŸ‘ (-1) = NO
            // Each member's vote is determined by their reaction(s)
            const votes = {};
            for (const reaction of reactions) {
              const username = reaction.user.login.toLowerCase();
              if (members.includes(username)) {
                // +1 (ğŸ‘) = yes, -1 (ğŸ‘) = no
                if (reaction.content === '+1') {
                  votes[username] = 'yes';
                } else if (reaction.content === '-1') {
                  votes[username] = 'no';
                }
              }
            }

            const yes = Object.values(votes).filter(v => v === 'yes').length;
            const no = Object.values(votes).filter(v => v === 'no').length;
            const pending = members.length - Object.keys(votes).length;

            // â”€â”€â”€ Step 5: Determine outcome â”€â”€â”€
            let status, label;
            if (yes >= majority) {
              status = 'âœ… Approved';
              label = 'vote:approved';
            } else if (no >= majority) {
              status = 'âŒ Rejected';
              label = 'vote:rejected';
            } else {
              status = `â³ ${yes}/${majority} approvals`;
              label = 'vote:pending';
            }

            // â”€â”€â”€ Step 6: Update labels â”€â”€â”€
            // Remove old vote labels (except deadline-passed)
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              ...context.repo,
              issue_number: context.issue.number
            });

            for (const l of currentLabels) {
              if (l.name.startsWith('vote:') && l.name !== 'vote:deadline-passed') {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number: context.issue.number,
                  name: l.name
                }).catch(() => {}); // Ignore if already removed
              }
            }

            // Add new label
            await github.rest.issues.addLabels({
              ...context.repo,
              issue_number: context.issue.number,
              labels: [label]
            });

            // â”€â”€â”€ Step 7: Post status update â”€â”€â”€
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: `**${status}** â€” ${yes} ğŸ‘, ${no} ğŸ‘, ${pending} pending`
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3: DEADLINE + REMINDERS
  # Runs daily. Resolves PRs that reached majority. Nags non-voters on the rest.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deadline:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // â”€â”€â”€ Setup â”€â”€â”€
            const { data: openPRs } = await github.rest.pulls.list({
              ...context.repo,
              state: 'open'
            });
            const now = Date.now();
            const cutoff48h = now - 48*60*60*1000;
            const cutoff24h = now - 24*60*60*1000;

            // Get committee from CODEOWNERS
            const codeowners = fs.readFileSync('.github/CODEOWNERS', 'utf8');
            const mentions = codeowners.match(/@[\w-]+/g) || [];
            const members = mentions.map(m => m.slice(1).toLowerCase());
            const membersOriginal = mentions.map(m => m.slice(1));
            const majority = Math.floor(members.length / 2) + 1;

            // â”€â”€â”€ Process each open PR â”€â”€â”€
            for (const pr of openPRs) {
              // Skip PRs less than 48 hours old (voting still in initial window)
              if (new Date(pr.created_at) >= cutoff48h) continue;

              // Skip PRs already resolved
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                ...context.repo,
                issue_number: pr.number
              });
              if (labels.some(l => l.name === 'vote:deadline-passed')) continue;

              // â”€â”€â”€ Find the voting comment â”€â”€â”€
              const { data: comments } = await github.rest.issues.listComments({
                ...context.repo,
                issue_number: pr.number
              });

              const votingComment = comments.find(c =>
                c.user.login === 'github-actions[bot]' &&
                c.body.includes('ğŸ—³ï¸') &&
                c.body.includes('Voting open')
              );

              if (!votingComment) continue;

              // â”€â”€â”€ Count votes from emoji reactions â”€â”€â”€
              const { data: reactions } = await github.rest.reactions.listForIssueComment({
                ...context.repo,
                comment_id: votingComment.id
              });

              const votes = {};
              for (const reaction of reactions) {
                const username = reaction.user.login.toLowerCase();
                if (members.includes(username)) {
                  if (reaction.content === '+1') {
                    votes[username] = 'yes';
                  } else if (reaction.content === '-1') {
                    votes[username] = 'no';
                  }
                }
              }

              const yes = Object.values(votes).filter(v => v === 'yes').length;
              const no = Object.values(votes).filter(v => v === 'no').length;

              // â”€â”€â”€ Handle outcome â”€â”€â”€
              const assignee = membersOriginal[Math.floor(Math.random() * membersOriginal.length)];

              if (yes >= majority) {
                // âœ… APPROVED â€” resolve and assign someone to merge
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number: pr.number,
                  labels: ['vote:deadline-passed', 'ready-to-merge']
                });
                await github.rest.issues.addAssignees({
                  ...context.repo,
                  issue_number: pr.number,
                  assignees: [assignee]
                });
                await github.rest.issues.createComment({
                  ...context.repo,
                  issue_number: pr.number,
                  body: `â° **Voting closed â€” APPROVED**\n\n` +
                        `Final tally: ${yes} ğŸ‘, ${no} ğŸ‘\n\n` +
                        `âœ… @${assignee} â€” please review and merge when ready.`
                });

              } else if (no >= majority) {
                // âŒ REJECTED â€” resolve and assign someone to close
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number: pr.number,
                  labels: ['vote:deadline-passed']
                });
                await github.rest.issues.addAssignees({
                  ...context.repo,
                  issue_number: pr.number,
                  assignees: [assignee]
                });
                await github.rest.issues.createComment({
                  ...context.repo,
                  issue_number: pr.number,
                  body: `â° **Voting closed â€” REJECTED**\n\n` +
                        `Final tally: ${yes} ğŸ‘, ${no} ğŸ‘\n\n` +
                        `âŒ @${assignee} â€” please close this PR.`
                });

              } else {
                // ğŸ¤” NO MAJORITY YET â€” nag non-voters (but only once per 24 hours)

                // Check if we already sent a reminder in the last 24 hours
                const lastReminder = comments
                  .filter(c =>
                    c.user.login === 'github-actions[bot]' &&
                    c.body.includes('ğŸ‘‹ Friendly reminder')
                  )
                  .pop(); // most recent

                if (lastReminder && new Date(lastReminder.created_at) >= cutoff24h) {
                  console.log(`PR #${pr.number}: reminder already sent in last 24h, skipping`);
                  continue;
                }

                // Find who hasn't voted
                const nonVoters = membersOriginal.filter(m =>
                  !Object.keys(votes).includes(m.toLowerCase())
                );

                const tags = nonVoters.map(m => `@${m}`).join(' ');
                await github.rest.issues.createComment({
                  ...context.repo,
                  issue_number: pr.number,
                  body: `ğŸ‘‹ **Friendly reminder** â€” this PR is waiting on votes.\n\n` +
                        `Current tally: ${yes} ğŸ‘, ${no} ğŸ‘ (need ${majority} for majority)\n\n` +
                        `Still waiting on: ${tags}\n\n` +
                        `React ğŸ‘ or ğŸ‘ on the [voting comment](${votingComment.html_url}) above.`
                });
              }
            }
